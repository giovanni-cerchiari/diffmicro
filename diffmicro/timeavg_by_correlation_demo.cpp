/*
Copyright: Mojtaba Norouzisadeh, Giovanni Cerchiari
e-mail: giovanni.cerchiari@gmail.com
e-mail: norouzi.mojtaba.sade@gmail.com

date: 05/2020 - 09/2020
*/

/*
This file is part of diffmicro.

    Diffmicro is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Diffmicro is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Diffmicro.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "timeavg_by_correlation.h"

#include "figure_opencv.h"
#include "correlation.h"
#include <cmath>
#include <iostream>


int dd_main(int argc, char* argv[])
{
	INDEX i,j,k;
	INDEX dim, dimp;
	FFTW_REAL *t;
	FFTW_REAL *yr, *yi;
	FFTW_REAL* out_r, *out_f, *out_f2;
	FFTW_REAL coef1, coef2;
	FFTW_REAL abs2_fromstart, abs2_fromend;
	FFTW_REAL dif_re, dif_im;
	FFTW_COMPLEX *y, *yinput, *yinput2, *y2;
	int rankdim[1];

	fftw_plan plan_direct, plan_direct2;

	//----------------------------------------------
	// some input
	dim = 90;
	t = new FFTW_REAL[dim];
	yr = new FFTW_REAL[dim];
	yi = new FFTW_REAL[dim];
	
	for (i = 0; i < dim; ++i)
	{
		t[i] = (FFTW_REAL)(i);
		yr[i] = t[i] * t[i] * std::exp(-0.1 * t[i]) * std::cos(0.5 * t[i]) / 100;
		yi[i] = t[i] * t[i] * std::exp(-0.05 * (t[i]-dim/4.)* (t[i] - dim / 4.)) 
			* std::sin(0.3 * t[i]) / 100;
	}
	yinput = (FFTW_COMPLEX*)(fftw_malloc(sizeof(FFTW_COMPLEX) * dim));
	yinput2 = (FFTW_COMPLEX*)(fftw_malloc(sizeof(FFTW_COMPLEX) * dim));
	for (i = 0; i < dim; ++i)
	{
		yinput2[i][0] = yinput[i][0] = yr[i];
		yinput2[i][1] = yinput[i][1] = yi[i];
	}
	
	//----------------------------------------------
	//----------------------------------------------
	// REGULAR CALCULATION

	out_r = new FFTW_REAL[dim];
	for (j = 0; j < dim; ++j)
	{
		out_r[j] = 0.0;
		k = 0;
		for (i = j; i < dim; ++i, ++k)
		{
			dif_re = yinput[i-j][0] - yinput[i][0];
			dif_im = yinput[i-j][1] - yinput[i][1];
			// in place average
			coef2 = (FFTW_REAL)(1.0) / (FFTW_REAL)(k + 1);
			coef1 = (FFTW_REAL)(k)*coef2;
			out_r[j] = coef1 * out_r[j] + coef2 * (dif_re* dif_re + dif_im* dif_im);
		}
	}

	//----------------------------------------------
	//----------------------------------------------
	// FFT based calculation

	//----------------------------------------------
	// Calculating the average of the absolute squares
	out_f = new FFTW_REAL[dim];
	out_f2 = new FFTW_REAL[dim];
	averagesabs2_array_cpu(dim, yinput, out_f);

	//----------------------------------------------
	// preparing Fourier variables

	// Calculating the closes power of 2 that allows for zero-padding
	dimp = (INDEX)(std::ceil(std::log((FFTW_REAL)(dim)) / std::log(2.0))) + 1;
	rankdim[0] = 1;
	for (i = 0; i < dimp; ++i) rankdim[0] *= 2;
	dimp = rankdim[0];

	// allocating memory
	y = (FFTW_COMPLEX*)(fftw_malloc(sizeof(FFTW_COMPLEX) * dimp));
	y2 = (FFTW_COMPLEX*)(fftw_malloc(sizeof(FFTW_COMPLEX) * dimp));

	// preparing plan
	fftw_init_threads();
	fftw_plan_with_nthreads(2);
	plan_direct = fftw_plan_dft(1, rankdim, y, y, FFTW_FORWARD, FFTW_ESTIMATE);
	plan_direct2 = fftw_plan_dft(1, rankdim, y2, y2, FFTW_FORWARD, FFTW_ESTIMATE);


	timeseriesanalysis_cpu(dim, yinput2, dimp, y2, &plan_direct2, out_f2);

	//-----------------------------------------------
	// copying data to the execution memory with normalization
	for (i = 0; i < dimp; ++i)
	{
		y[i][0] = 0.0;
		y[i][1] = 0.0;
	}
	gain_complex_cpu(4, dim, yinput, (FFTW_REAL)( 1./std::sqrt((FFTW_REAL)(dimp)) ) , y);
	//----------------------------------------------

	// FFT execution
	fftw_execute(plan_direct);
	// evaluating abs^2
	complex_abs2_cpu(4, dimp, y, y);
	// FFT execution. Given the conditions
	// - we are only interested in the real part
	// - we start from a real function generated by the absolute value
	// Then the direct and inverse FFT are equivalent. We can re-use plan_direct!
	fftw_execute(plan_direct);
	update_with_divrebyramp_cpu(4, dim, y, out_f);

	//------------------------------------------------
	//------------------------------------------------
	// DISPLAY
	window_display_opencv* fig;
	scatter_opencv* sc;
	sc = new scatter_opencv;
	sc->dimpoint = dim;
	sc->x = t;
	sc->y = yr;
	fig = plot(-1, sc);
	sc->color_normal = cv::Scalar(0, 0, 255);
	sc = new scatter_opencv;
	sc->dimpoint = dim;
	sc->x = t;
	sc->y = yi;
	sc->set_marker_type(MARKER_CIRCLE_OPENCV);
	sc->color_normal = cv::Scalar(255, 100, 100);
	fig = plot(fig->id, sc);
	sc = new scatter_opencv;
	sc->dimpoint = dim;
	sc->x = t;
	sc->y = out_r;
	fig = plot(-1, sc);
	sc->set_marker_type(MARKER_CIRCLE_OPENCV);
	sc->color_normal = cv::Scalar(0, 0, 255);
	sc = new scatter_opencv;
	sc->dimpoint = dim;
	sc->x = t;
	sc->y = out_f;
	fig = plot(fig->id, sc);
	sc = new scatter_opencv;
	sc->dimpoint = dim;
	sc->x = t;
	sc->y = out_f2;
	sc->set_marker_type(MARKER_NONE_OPENCV);
	sc->color_normal = cv::Scalar(0, 255, 255);
	fig = plot(fig->id, sc);

	waitkeyboard(0);
	//------------------------------------------------
	delete[] t, yr, yi;
	delete[] out_r, out_f, out_f2;
	fftw_free(y);
	fftw_free(y2);
	fftw_free(yinput);
	fftw_free(yinput2);
	fftw_destroy_plan(plan_direct);
	fftw_destroy_plan(plan_direct2);
	fftw_cleanup_threads();
	return 0;
}


